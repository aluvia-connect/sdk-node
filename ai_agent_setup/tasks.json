{
    "project": "Aluvia Client (Node.js)",
    "description": "Node-only local HTTP(S) proxy client that connects to Aluvia using a user API token, fetches /user config, maintains rules via polling, and exposes a local proxy URL on 127.0.0.1:<PORT>.",
    "tasks": [
      {
        "id": "0.1",
        "title": "Initialize Node/TypeScript project",
        "description": "Create the basic Node.js + TypeScript scaffold for @aluvia/aluvia-node.",
        "files": [
          "package.json",
          "tsconfig.json",
          "src/index.ts"
        ],
        "steps": [
          "Run `npm init -y` to initialize the package.",
          "Add dev dependencies: `typescript`, `@types/node`.",
          "Create `tsconfig.json` with at least: `rootDir: src`, `outDir: dist`, suitable `target` and `module` for Node 18+.",
          "Create a `src/` directory and a placeholder `src/index.ts` file.",
          "Add an npm script `\"build\": \"tsc\"`."
        ],
        "acceptanceCriteria": [
          "Running `npm run build` compiles TypeScript successfully and generates a `dist/` directory.",
          "No TypeScript or Node resolution errors are reported."
        ]
      },
      {
        "id": "0.2",
        "title": "Define package metadata",
        "description": "Configure package.json for publishing the library as @aluvia/aluvia-node.",
        "files": [
          "package.json"
        ],
        "steps": [
          "Set `name` to `\"@aluvia/aluvia-node\"`.",
          "Set `main` to `\"dist/index.js\"` and `types` to `\"dist/index.d.ts\"`.",
          "Ensure scripts include at least `\"build\": \"tsc\"` and `\"prepare\": \"npm run build\"`.",
          "Optionally set `\"engines\"` to require Node 18+ if relying on native fetch.",
          "Verify that `files` (if used) include `dist/`."
        ],
        "acceptanceCriteria": [
          "`npm pack` produces a tarball that contains the compiled `dist/` output after running `npm run build`.",
          "The package metadata is valid (no npm warnings for missing entry points)."
        ]
      },
      {
        "id": "1.1",
        "title": "Define public types and options",
        "description": "Create the core TypeScript types for options and session objects.",
        "files": [
          "src/types.ts",
          "src/index.ts"
        ],
        "steps": [
          "Create `src/types.ts` and define `GatewayProtocol`, `AluviaClientOptions`, and `AluviaClientSession`:",
          "GatewayProtocol = 'http' | 'https'.",
          "AluviaClientOptions fields: `token` (required), `apiBaseUrl?`, `pollIntervalMs?`, `gatewayProtocol?`, `gatewayPort?`, `localPort?`, `logLevel?`.",
          "AluviaClientSession fields: `host`, `port`, `url`, and async `stop()`.",
          "Export these types from `src/types.ts`.",
          "Ensure `src/index.ts` re-exports these types."
        ],
        "acceptanceCriteria": [
          "The types compile successfully and are importable from `@aluvia/aluvia-node`.",
          "All fields match the latest spec, including optional `localPort` and gateway protocol/port options."
        ]
      },
      {
        "id": "1.2",
        "title": "Implement index.ts export surface",
        "description": "Expose the main public API from index.ts.",
        "files": [
          "src/index.ts",
          "src/AluviaClient.ts",
          "src/types.ts"
        ],
        "steps": [
          "Create `src/AluviaClient.ts` (can be a stub class for now).",
          "In `src/index.ts`, export `AluviaClient` from `./AluviaClient`.",
          "Re-export `AluviaClientOptions`, `AluviaClientSession`, and `GatewayProtocol` from `./types`."
        ],
        "acceptanceCriteria": [
          "A consumer can write `import { AluviaClient } from '@aluvia/aluvia-node';` without type or module resolution errors.",
          "Public types are accessible from the package root."
        ]
      },
      {
        "id": "2.1",
        "title": "Implement error classes",
        "description": "Define custom error classes for user token and API errors.",
        "files": [
          "src/errors.ts"
        ],
        "steps": [
          "Create `src/errors.ts`.",
          "Implement `MissingUserTokenError extends Error`.",
          "Implement `InvalidUserTokenError extends Error`.",
          "Implement `ApiError extends Error` with an optional `statusCode` property.",
          "Implement `ProxyStartError extends Error`."
        ],
        "acceptanceCriteria": [
          "All error classes can be imported and instantiated without issues.",
          "`ApiError` instances carry a `statusCode` when provided."
        ]
      },
      {
        "id": "2.2",
        "title": "Implement logging helper",
        "description": "Create a simple logger that respects logLevel.",
        "files": [
          "src/logger.ts"
        ],
        "steps": [
          "Create `Logger` class with constructor accepting `level: 'silent' | 'info' | 'debug'`.",
          "Implement methods: `info`, `debug`, `warn`, `error`.",
          "Ensure `silent` only logs `error`, `info` logs info/warn/error, and `debug` logs everything.",
          "Prefix logs with `[aluvia][level]` for consistency."
        ],
        "acceptanceCriteria": [
          "Instantiating Logger with each log level produces the expected logging behavior.",
          "No logs are emitted for `info` and `debug` when level is `silent`."
        ]
      },
      {
        "id": "3.1",
        "title": "Implement HTTP client for /user",
        "description": "Create a small HTTP client wrapper to call GET /user with optional If-None-Match.",
        "files": [
          "src/httpClient.ts"
        ],
        "steps": [
          "Decide on HTTP mechanism: native fetch (Node 18+) or a small library (e.g. node-fetch).",
          "Define `UserApiResponse` type with fields: `proxy_username`, `proxy_password`, `rules`, `session_id`, `target_geo`.",
          "Implement `getUser(apiBaseUrl, token, etag?)` returning `{ status, etag, body }`.",
          "Determine URL as `${apiBaseUrl.replace(/\\/$/, '')}/user`.",
          "Send headers: `Authorization: Bearer <token>`, `Accept: application/json`, `If-None-Match` when `etag` is provided.",
          "Parse the response status, ETag header, and body (only on 200)."
        ],
        "acceptanceCriteria": [
          "For a simulated 200 response, `getUser` returns `{ status: 200, etag: '...', body: {...} }`.",
          "For a simulated 304 response, `getUser` returns `{ status: 304, etag: '...', body: null }`.",
          "No unhandled JSON parse errors when body is empty on 304."
        ]
      },
      {
        "id": "4.1",
        "title": "Define RawProxyConfig and UserNetworkConfig types",
        "description": "Define the state structure used by the ConfigManager.",
        "files": [
          "src/ConfigManager.ts",
          "src/ConfigManager.types.ts"
        ],
        "steps": [
          "Create `src/ConfigManager.types.ts` (or keep types inside `ConfigManager.ts`).",
          "Define `RawProxyConfig` with fields: `protocol`, `host`, `port`, `username`, `password`.",
          "`host` should be typed as the literal `'gateway.aluvia.io'`.",
          "Define `UserNetworkConfig` with fields: `rawProxy`, `rules`, `sessionId`, `targetGeo`, `etag`."
        ],
        "acceptanceCriteria": [
          "Types compile and can be imported from `ConfigManager.ts` and `ProxyServer.ts`.",
          "`RawProxyConfig` aligns with the gateway connection spec (protocol, host, port, basic auth)."
        ]
      },
      {
        "id": "4.2",
        "title": "Implement ConfigManager skeleton",
        "description": "Create ConfigManager class with internal state and constructor wire-up.",
        "files": [
          "src/ConfigManager.ts",
          "src/logger.ts",
          "src/ConfigManager.types.ts",
          "src/httpClient.ts",
          "src/errors.ts"
        ],
        "steps": [
          "Implement `ConfigManager` constructor that accepts: `token`, `apiBaseUrl`, `pollIntervalMs`, `gatewayProtocol`, `gatewayPort`, and `logLevel`.",
          "Initialize `this.config` as `null` and `this.timer` as `null`.",
          "Create an internal `Logger` instance using `logLevel`.",
          "Stub methods: `init()`, `startPolling()`, `stopPolling()`, and `getConfig()` with correct signatures."
        ],
        "acceptanceCriteria": [
          "ConfigManager compiles and can be instantiated with all required options.",
          "No behavior yet, but no TypeScript errors in consumer modules."
        ]
      },
      {
        "id": "4.3",
        "title": "Implement ConfigManager.init()",
        "description": "Fetch initial /user config and populate this.config, or throw appropriate errors.",
        "files": [
          "src/ConfigManager.ts",
          "src/httpClient.ts",
          "src/errors.ts"
        ],
        "steps": [
          "Call `getUser(apiBaseUrl, token)` with no ETag.",
          "If status is 401 or 403, throw `InvalidUserTokenError`.",
          "If status is 200 and body is not null, map the body into `UserNetworkConfig`:",
          "  - Construct `rawProxy` using: `gatewayProtocol`, `gatewayPort`, `host = 'gateway.aluvia.io'`, `username = proxy_username`, `password = proxy_password`.",
          "Store `rules`, `sessionId`, `targetGeo` from body.",
          "Store `etag` from the response.",
          "If an unexpected status (e.g. 4xx/5xx) occurs, throw `ApiError`.",
          "Set `this.config` to the new `UserNetworkConfig`.",
          "If the call fails (network error) and no previous config exists, propagate error so the caller can fail startup."
        ],
        "acceptanceCriteria": [
          "For a simulated 200 response, `init()` sets `this.config` with expected values.",
          "For a simulated 401/403 response, `init()` throws `InvalidUserTokenError`.",
          "For other 4xx/5xx, `init()` throws `ApiError`.",
          "If `init()` fails, `this.config` remains null."
        ]
      },
      {
        "id": "4.4",
        "title": "Implement ConfigManager.getConfig()",
        "description": "Expose the current in-memory config to other components.",
        "files": [
          "src/ConfigManager.ts"
        ],
        "steps": [
          "Implement `getConfig()` to return `this.config`.",
          "No mutation should occur in this method."
        ],
        "acceptanceCriteria": [
          "`getConfig()` returns `null` before `init()` is called and a non-null object after a successful `init()` in tests.",
          "No side effects occur when calling `getConfig()`."
        ]
      },
      {
        "id": "4.5",
        "title": "Implement ConfigManager.startPolling() and stopPolling()",
        "description": "Maintain configuration freshness by polling /user with ETag.",
        "files": [
          "src/ConfigManager.ts",
          "src/httpClient.ts"
        ],
        "steps": [
          "In `startPolling()`, if a timer already exists, do nothing.",
          "Create a `setInterval` loop using `pollIntervalMs`.",
          "On each interval tick:",
          "  - If `this.config` is null, optionally skip or log a warning.",
          "  - Call `getUser(apiBaseUrl, token, currentConfig.etag)`.",
          "  - If status is 304, log debug and leave config unchanged.",
          "  - If status is 200, map to a new `UserNetworkConfig` and replace `this.config`.",
          "  - If network/5xx, log a warning and keep old config.",
          "In `stopPolling()`, clear the interval and set timer to null."
        ],
        "acceptanceCriteria": [
          "When `getUser` returns 304 repeatedly, `this.config` is not changed.",
          "When `getUser` returns 200 with new data and new ETag, `this.config` is updated.",
          "After calling `stopPolling()`, no further HTTP calls are made."
        ]
      },
      {
        "id": "5.1",
        "title": "Implement wildcard rule matcher",
        "description": "Add hostname pattern matching logic for rules like '*', '*.example.com', 'google.*', etc.",
        "files": [
          "src/rules.ts"
        ],
        "steps": [
          "Create `src/rules.ts`.",
          "Implement `matchPattern(hostname: string, pattern: string): boolean`.",
          "Support these behaviors:",
          "  - '*' matches any hostname.",
          "  - '*.example.com' matches subdomains of example.com.",
          "  - 'example.com' matches exactly example.com.",
          "  - 'google.*' matches 'google.com', 'google.co.uk', etc.",
          "Ignore `AUTO` for now (treated as not matching; handled later by higher-level semantics)."
        ],
        "acceptanceCriteria": [
          "Unit tests confirm: '*.google.com' matches 'foo.google.com' but not 'google.com'.",
          "'google.*' matches 'google.com' and 'google.co.uk'.",
          "'*' matches any hostname.",
          "'example.com' only matches 'example.com'."
        ]
      },
      {
        "id": "5.2",
        "title": "Implement shouldProxy() decision function",
        "description": "Implement the rule-based decision for whether a hostname should be proxied.",
        "files": [
          "src/rules.ts"
        ],
        "steps": [
          "Implement `shouldProxy(hostname: string, rules: string[]): boolean`.",
          "Semantics:",
          "  - No rules (`[]`) => return false (no proxy).",
          "  - If rules contain '*' and no negative match => proxy all.",
          "  - Rules may contain negative patterns prefixed with '-' (e.g. '-example.com'), which mean bypass proxy for hosts matching them.",
          "  - Without '*', proxy if hostname matches any non-negative pattern.",
          "  - Treat 'AUTO' as a placeholder for now (either ignore or document its behavior; simplest: ignore until AUTO list is defined)."
        ],
        "acceptanceCriteria": [
          "Tests:",
          "  - rules = [] => shouldProxy('example.com') === false.",
          "  - rules = ['*'] => shouldProxy('example.com') === true.",
          "  - rules = ['example.com'] => shouldProxy('example.com') === true, but false for 'foo.com'.",
          "  - rules = ['*', '-example.com'] => shouldProxy('example.com') === false, but true for 'foo.com'.",
          "  - rules = ['AUTO', 'example.com'] => shouldProxy('example.com') === true (assuming AUTO ignored for now)."
        ]
      },
      {
        "id": "6.1",
        "title": "Add proxy-chain dependency",
        "description": "Install and wire up proxy-chain as the underlying HTTP(S) proxy engine.",
        "files": [
          "package.json"
        ],
        "steps": [
          "Run `npm install proxy-chain` to add the dependency.",
          "Ensure TypeScript can import `Server` from 'proxy-chain'.",
          "If needed, create minimal type declarations for proxy-chain in a `.d.ts` file."
        ],
        "acceptanceCriteria": [
          "TypeScript can import `{ Server }` from 'proxy-chain' with no compilation errors.",
          "`npm run build` still succeeds."
        ]
      },
      {
        "id": "6.2",
        "title": "Implement ProxyServer skeleton",
        "description": "Create the ProxyServer class that will manage the local HTTP(S) proxy server lifecycle.",
        "files": [
          "src/ProxyServer.ts",
          "src/ConfigManager.ts",
          "src/logger.ts"
        ],
        "steps": [
          "Create `src/ProxyServer.ts`.",
          "Import `Server as ProxyChainServer` from 'proxy-chain'.",
          "Define class `ProxyServer` with constructor accepting `configManager: ConfigManager` and optional `{ logLevel }`.",
          "Add private fields: `server: ProxyChainServer | null` and a `Logger` instance.",
          "Stub `start(port?: number)` and `stop()` methods."
        ],
        "acceptanceCriteria": [
          "ProxyServer compiles and can be instantiated with a ConfigManager.",
          "No runtime logic yet, only structure and types."
        ]
      },
      {
        "id": "6.3",
        "title": "Implement ProxyServer.start()",
        "description": "Start a local HTTP proxy on 127.0.0.1:<port> using proxy-chain.",
        "files": [
          "src/ProxyServer.ts"
        ],
        "steps": [
          "Implement `start(port?: number)`:",
          "  - Determine `listenPort`: use provided `port` or `0` for an ephemeral port.",
          "  - Instantiate `ProxyChainServer` with `port: listenPort` and a `prepareRequestFunction` (can be a stub initially returning null).",
          "  - Start the server and wait until it is listening.",
          "  - Call `server.server.address()` to get the actual port (cast to `AddressInfo`).",
          "  - Return `{ host: '127.0.0.1', port: actualPort, url: 'http://127.0.0.1:<actualPort>' }`.",
          "Store the server instance on `this.server`."
        ],
        "acceptanceCriteria": [
          "Calling `start()` resolves with a valid host/port/url.",
          "You can verify in tests that the port is listening (e.g., by attempting a TCP connection)."
        ]
      },
      {
        "id": "6.4",
        "title": "Implement ProxyServer.stop()",
        "description": "Stop the local proxy server and free resources.",
        "files": [
          "src/ProxyServer.ts"
        ],
        "steps": [
          "If `this.server` is null, return early.",
          "Call `await this.server.close()`.",
          "Set `this.server` to null."
        ],
        "acceptanceCriteria": [
          "After calling `stop()`, the proxy no longer listens on its port.",
          "Calling `stop()` multiple times does not throw errors."
        ]
      },
      {
        "id": "6.5",
        "title": "Integrate ConfigManager and shouldProxy in prepareRequestFunction",
        "description": "Use the current config to decide per-request whether to route through Aluvia or direct.",
        "files": [
          "src/ProxyServer.ts",
          "src/ConfigManager.ts",
          "src/rules.ts"
        ],
        "steps": [
          "In `start()`, configure `prepareRequestFunction` for ProxyChainServer:",
          "  - Retrieve current config via `configManager.getConfig()`.",
          "  - If config is null, log a warning and return null (direct).",
          "  - Extract hostname from params (use `params.hostname` or derive from URL/host header).",
          "  - Call `shouldProxy(hostname, cfg.rules)`.",
          "  - If false, return null to bypass upstream proxy.",
          "  - If true, build upstream proxy URL from `cfg.rawProxy`:",
          "    - `${protocol}://${encodeURIComponent(username)}:${encodeURIComponent(password)}@${host}:${port}`.",
          "  - Return `{ upstreamProxyUrl }`.",
          "Handle missing hostname gracefully by defaulting to direct."
        ],
        "acceptanceCriteria": [
          "When rules = ['*'], all requests are routed via upstream proxy.",
          "When rules = [], all requests go direct.",
          "No crashes occur when config is temporarily null; proxy defaults to direct and logs a warning."
        ]
      },
      {
        "id": "7.1",
        "title": "Implement AluviaClient constructor",
        "description": "Wire options, defaults, ConfigManager, and ProxyServer in AluviaClient.",
        "files": [
          "src/AluviaClient.ts",
          "src/types.ts",
          "src/errors.ts",
          "src/ConfigManager.ts",
          "src/ProxyServer.ts"
        ],
        "steps": [
          "Create `AluviaClient` class.",
          "In the constructor, accept `AluviaClientOptions`.",
          "If `options.token` is missing or empty, throw `MissingUserTokenError`.",
          "Apply defaults:",
          "  - `apiBaseUrl = options.apiBaseUrl ?? 'https://api.aluvia.io/v1'`.",
          "  - `pollIntervalMs = options.pollIntervalMs ?? 5000`.",
          "  - `gatewayProtocol = options.gatewayProtocol ?? 'http'`.",
          "  - `gatewayPort` default: 8080 for http, 8443 for https, unless `options.gatewayPort` is provided.",
          "  - `logLevel = options.logLevel ?? 'info'`.",
          "Instantiate `ConfigManager` with these values.",
          "Instantiate `ProxyServer` with `configManager` and `logLevel`.",
          "Initialize internal state: `this.session = null`, `this.started = false`."
        ],
        "acceptanceCriteria": [
          "Instantiating AluviaClient with a valid token and no other options succeeds.",
          "Instantiating without `token` throws `MissingUserTokenError`.",
          "Defaults for gateway protocol and port align with the spec (http->8080, https->8443)."
        ]
      },
      {
        "id": "7.2",
        "title": "Implement AluviaClient.start()",
        "description": "Start config manager, proxy server, polling, and return an AluviaClientSession.",
        "files": [
          "src/AluviaClient.ts"
        ],
        "steps": [
          "If `this.started` is true and `this.session` is non-null, return the existing session.",
          "Call `await this.configManager.init()`; let it throw for invalid token or API errors.",
          "Call `await this.proxyServer.start(options.localPort)`.",
          "Extract `host`, `port`, `url` from the result.",
          "Call `this.configManager.startPolling()`.",
          "Create an `AluviaClientSession` object:",
          "  - `host`, `port`, `url` from above.",
          "  - `stop()` method that stops the proxy server and polling, and clears internal state.",
          "Set `this.session` and `this.started = true`.",
          "Return the session."
        ],
        "acceptanceCriteria": [
          "On valid configuration, `start()` resolves with a session containing host, port, and url.",
          "When `localPort` is provided in options, the session port matches that port.",
          "When token is invalid, `start()` rejects with `InvalidUserTokenError`.",
          "Subsequent calls to `start()` return the same session while it is active."
        ]
      },
      {
        "id": "7.3",
        "title": "Implement AluviaClient.stop()",
        "description": "Provide a top-level method to stop the proxy and polling.",
        "files": [
          "src/AluviaClient.ts"
        ],
        "steps": [
          "If `this.started` is false, return immediately with no error.",
          "Call `await this.proxyServer.stop()`.",
          "Call `this.configManager.stopPolling()`.",
          "Clear `this.session` and set `this.started = false`."
        ],
        "acceptanceCriteria": [
          "After calling `stop()`, the proxy is no longer listening and no polling occurs.",
          "Calling `stop()` twice does not throw and has no negative side effects."
        ]
      },
      {
        "id": "8.1",
        "title": "Add minimal integration smoke test",
        "description": "Test the happy-path flow end-to-end with mocks.",
        "files": [
          "test/integration.test.ts",
          "src/AluviaClient.ts",
          "src/ConfigManager.ts",
          "src/ProxyServer.ts",
          "src/httpClient.ts"
        ],
        "steps": [
          "Set up a test runner (e.g., Jest, Vitest, or Node's built-in test).",
          "Mock `getUser()` to return a valid config with `rules: ['*']`, dummy credentials, and ETag.",
          "Instantiate `AluviaClient` with a fake token and `logLevel: 'silent'`.",
          "Call `client.start()` and assert that a session is returned with host, port, and url.",
          "Optionally, perform an HTTP request through the local proxy to a simple test server to verify the connection path (can be basic)."
        ],
        "acceptanceCriteria": [
          "The integration test passes without unhandled rejections.",
          "The session returned by `start()` uses a listening port.",
          "Mocks for `getUser()` are called as expected."
        ]
      },
      {
        "id": "8.2",
        "title": "Document basic usage in README",
        "description": "Add a minimal developer-facing usage example to README.",
        "files": [
          "README.md"
        ],
        "steps": [
          "Add install instructions: `npm install @aluvia/aluvia-node`.",
          "Show a code snippet using `new AluviaClient({ token: process.env.ALV_USER_TOKEN })` and `await client.start()`.",
          "Demonstrate using `session.url` with Playwright (via `proxy: { server: session.url }`).",
          "Demonstrate using `session.url` with Axios + `HttpsProxyAgent`.",
          "Mention how to optionally set `gatewayProtocol`, `gatewayPort`, and `localPort`."
        ],
        "acceptanceCriteria": [
          "README example matches the implemented public API and compiles if copied into a basic Node project.",
          "Usage explains token requirement and the basic flow (start, use session.url, stop)."
        ]
      }
    ]
  }
  